typeof(1:3)
C <- matrix(nrow=nrow(M), ncol=ncol(M))
for(i in 1:nrow(M)){
for(j in 1:ncol(M)){
C[i,j] <- cofactorize(M, i, j)
}
}
C
?vectorize
?sapply
aaply(M, FUN=cofactorize, M, 1:3, 1:3)
aaply(M, c(1,2), FUN=cofactorize, M, 1:3, 1:3)
aaply(M, c(1,2), .fun=cofactorize, M, 1:3, 1:3)
aaply(M, c(1,2), .fun=cofactorize, M, 1:3, 1:3)
MInv <- C/det(M)
MInv
solve(M)
M <- matrix(c(1,2,3,4,9,6,7,8,9),nrow=3)
cofactorize <- function(M, i, j){
return(((-1)^(i+j)) * det(M[-i,-j]))
}
C <- matrix(nrow=nrow(M), ncol=ncol(M))
for(i in 1:nrow(M)){
for(j in 1:ncol(M)){
C[i,j] <- cofactorize(M, i, j)
}
}
MInv <- C/det(M)
MInv == solve(M)
MInv
solve(M)
MInv <- t(C)/det(M)
MInv
solve(M)
MInv == solve(M)
myinverse <- function(M){
C <- matrix(nrow=nrow(M), ncol=ncol(M))
for(i in 1:nrow(M)){
for(j in 1:ncol(M)){
C[i,j] <- cofactorize(M, i, j)
}
}
return(t(C)/det(M))
}
M <- matrix(c(1,2,3,4,9,6,7,8,9),nrow=3)
A <- matrix(c(1,1,1,1,0,1,3,4),nrow=4)
A
AtA <- t(A) %*% A
b <- matrix(c(0,8,8,19), nrow=4)
b
Atb <- t(A) %*% b
b <- matrix(c(0,8,8,20), nrow=4)
A <- matrix(c(1,1,1,1,0,1,3,4),nrow=4)
b <- matrix(c(0,8,8,20), nrow=4)
AtA <- t(A) %*% A
Atb <- t(A) %*% b
A <- matrix(c(1,1,1,1,0,1,3,4),nrow=4)
b <- matrix(c(0,8,8,20), nrow=4)
AtA <- t(A) %*% A
Atb <- t(A) %*% b
solve(AtA) %*% Atb
library(pracma)
rref(AtA)
Atb <- t(A) %*% b
Atb
cbind(AtA,Atb)
rref(cbind(AtA,Atb))
solve(AtA) %*% Atb
xhat <- solve(AtA) %*% Atb
e <- A %*% xhat - b
e
A %*% xhat - b
(A %*% xhat) - b
A <- matrix(c(1,1,1,1,0,1,3,4),nrow=4)
b <- matrix(c(0,8,8,19), nrow=4)
A <- matrix(c(1,1,1,1,0,1,3,4),nrow=4)
b <- matrix(c(0,8,8,19), nrow=4)
AtA <- t(A) %*% A
Atb <- t(A) %*% b
AtA
Atb
xhat <- solve(AtA) %*% Atb
xhat
e <- (A %*% xhat) - b
e
A <- matrix(c(1,1,1,1,0,1,3,4),nrow=4)
b <- matrix(c(0,8,8,20), nrow=4)
AtA <- t(A) %*% A
Atb <- t(A) %*% b
xhat <- solve(AtA) %*% Atb
e <- (A %*% xhat) - b
e
p <- matrix(c(1,5,13,17),nrow=4)
rref(cbind(A,p))
solve(A) %*% p
solve(A)
A
rref(cbind(A,b))
cbind(A,b)
rref(cbind(A,b))
rref(cbind(A,p))
rref(cbind(A,p))
rref(cbind(A,p))
((A %*% xhat) - b) * ((A %*% xhat) - b)
c(1,2,3,4) * c(1,2,3,4)
c(1,2,3,4) %*% c(1,2,3,4)
((A %*% xhat) - b) %*% ((A %*% xhat) - b)
((A %*% xhat) - b)
((A %*% xhat) - b)
((A %*% xhat) - b) %*% t((A %*% xhat) - b)
t((A %*% xhat) - b) %*% ((A %*% xhat) - b)
esquared <- t((A %*% xhat) - b) %*% ((A %*% xhat) - b)
esquared
p <- matrix(c(1,5,13,17),nrow=4)
rref(cbind(A,p))
e <- b - p
e <- b - p
t(e) %*% p
A
t(e) %*% A[,1]
t(e) %*% A[,2]
die1 <- c(rep(1,6),rep(2,6),rep(3,6),rep(4,6),rep(5,6),rep(6,6))
die2 <- rep(1:6,6)
Samplespace <- data.frame(die1 = die1, die2 = die2, sum = die1 + die2)
nrow(Samplespace[Samplespace$sum == 3,]) / nrow(Samplespace)
n <- 25
365^25
5*4*3*2
5*4
25*24
6*5
n <- 365*((25*24)/2)
d <- 365^25
n/d
d <- 365^25
n <- 365*((25*24)/2)
((25*24)/2)
((25*24)/2)
?factorial
e <- factorial(365+25-1)/(factorial(25)*factorial(365-1))
install.packages("combinat")
n/d
300 * (1/365) * 365
300 * (1/365)^2 * 365
p1 <- (1/365)^2
p1 * 365
p1 * 365 == 1/365
p2 <- p1 * 365
p2 == 1/365
300 * p1 * p2
19203801283910283 * p1 * p2
365 * p1 * p2
p1 <- (1/365)^2
p2 <- p1 * 365
1.64399790e+39/3.17289491e+38
3.17289491e+38/1.64399790e+39
sumprod(4,5,6)
cumprod(4,5,6)
cumprod(c(4,5,6))
prod(4,5,6)
5:2
365-25
length(365:340)
length(365:341)
p <- prod(365:341)/(365^25)
pdiff <- prod(365:341)/(365^25)
psame <- 1 - pdiff
365-50
pdiff <- prod(365:316)/(365^25)
pdiff <- prod(365:316)/(365^50)
psame <- 1-pdiff
expectedValue <- function(vec){
return(sum(vec)/length(vec))
}
expectedValue(c(1,2,3,4,5))
mean(c(1,2,3,4,5))
mean(c(1,2,3,4,5)) == expectedValue(c(1,2,3,4,5))
standardDeviation <- function(vec){
return(sqrt(sum((vec-expectedValue(vec))^2)/length(vec)))
}
standardDeviation(c(2,4,4,4,5,5,7,9))
stdev(c(2,4,4,4,5,5,7,9))
sd(c(2,4,4,4,5,5,7,9))
?sd
standardDeviation(c(2,4,4,4,5,5,7,9)) == sd(c(2,4,4,4,5,5,7,9))
vec <- c(2,4,4,4,5,5,7,9)
standardDeviation(vec) == sd(vec)
standardDeviation <- function(vec){
return(sqrt(sum((vec-expectedValue(vec))^2)/(length(vec)-1)))
}
sd(vec) == standardDeviation(vec)
movingStats <- function(statsList = list(), vec){
if(length(statsList) != 0){
nnew <- statsList$n + length(vec)
meannew <- (statsList$n*statsList$mean + sum(vec))/nnew
sumxold <- statsList$n*statsList$mean
sumxnew <- sumxold + sum(vec)
sumxsquarednew <- statsList$sumxsquared + sum(vec^2)
nsdsquarednew <- nnew*meannew^2 - 2*meannew*sumxnew + sumxsquarednew
sdnew <- sqrt(nsdsquarednew/nnew)
}else{
nnew <- length(vec)
meannew <- sum(vec) / nnew
sumxnew <- sum(vec)
sumxsquarednew <- sum(vec^2)
nsdsquarednew <- nnew*meannew^2 - 2*meannew*sumxnew + sumxsquarednew
sdnew <- sqrt(nsdsquarednew/nnew)
}
return(list(mean = meannew, sd = sdnew, n = nnew, sumxsquared = sumxsquarednew))
}
vec1 <- c(80,2,74,65,99,40,29,46,91)
vec2 <- c(5,7,18,93,66,59)
statsList1 <- movingStats(vec = vec1)
movingStats(statsList = statsList1, vec = vec2)
C <- matrix(cbind(1,.8,.6, .8,1,.7, .6,.7,1),nrow=3)
U <- t(chol(R))
U <- t(chol(C))
U
random.normal <- matrix(rnorm(nvars*numobs,0,1), nrow = nvars, ncol = numobs)
nvars <- dim(U)[1]
numobs <- 10000
set.seed(42)
random.normal <- matrix(rnorm(nvars*numobs,0,1), nrow = nvars, ncol = numobs)
X <- t(U %*% random.normal)
raw <- as.data.frame(X)
names(raw) <- c("claims", "potholes", "emergencies")
cor(raw)
pairs(head(raw, 500))
?chol
pairs(head(raw, 500))
C
U
nvars
numobs
rnorm(nvars*numobs,0,1)
random.normal
X
head(X)
raw
head(raw)
C <- matrix(cbind(1,.8,.6, .8,1,.7, .6,.7,1),nrow=3)
U <- t(chol(C))
nvars <- dim(U)[1]
numobs <- 10000
set.seed(42)
random.normal <- matrix(rnorm(nvars*numobs,0,1), nrow = nvars, ncol = numobs)
X <- t(U %*% random.normal)
raw <- as.data.frame(X)
names(raw) <- c("claims", "potholes", "emergencies")
cor(raw)
pairs(head(raw, 500))
cor(raw)
eigen(cor(raw))
as.matrix(raw) %*% eigen(cor(raw))$vectors
proj <- as.matrix(raw) %*% eigen(cor(raw))$vectors
pairs(head(prpj,500))
pairs(head(proj,500))
eigen(cor(raw))
eigen(cor(raw))$vectors[,1]
eigen(cor(raw))$vectors[,1] %*% eigen(cor(raw))$vectors[,2]
eigen(cor(raw))$vectors[,1] %*% eigen(cor(raw))$vectors[,3]
eigen(cor(raw))$vectors[,2] %*% eigen(cor(raw))$vectors[,3]
eigen(cor(raw))$vectors[,2:3]
setwd("E:/Downloads/Courses/CUNY/SPS/Git/IS 605 Fundamentals of Computational Mathematics/Assignment 7")
autodata <- scan("auto-mpg.data")
autodata <- t(matrix(autodata, nrow = 5))
means <- colMeans(autodata)
autodataCov <- matrix(ncol = ncol(autodata), nrow = nrow(autodata))
for(i in 1:ncol(autodata)){
autodataCov[,i] <- autodata[,i] - means[i]
}
meansCov <- colMeans(autodataCov)
covMat <- matrix(nrow = 5, ncol = 5)
for(i in 1:nrow(covMat)){
for(j in 1:ncol(covMat)){
covMat[i,j] <- mean(autodataCov[,i] * autodataCov[,j])
}
}
corrMat <- matrix(nrow = 5, ncol = 5)
for(i in 1:nrow(corrMat)){
for(j in 1:ncol(corrMat)){
corrMat[i,j] <- covMat[i,j] /
(standardDeviation(autodata[,i])*standardDeviation(autodata[,j]))
}
}
standardDeviation <- function(vec){
return(sqrt(sum((vec-expectedValue(vec))^2)/(length(vec)-1)))
}
expectedValue <- function(vec){
return(sum(vec)/length(vec))
}
setwd("E:/Downloads/Courses/CUNY/SPS/Git/IS 605 Fundamentals of Computational Mathematics/Assignment 7")
autodata <- scan("auto-mpg.data")
autodata <- t(matrix(autodata, nrow = 5))
means <- colMeans(autodata)
autodataCov <- matrix(ncol = ncol(autodata), nrow = nrow(autodata))
for(i in 1:ncol(autodata)){
autodataCov[,i] <- autodata[,i] - means[i]
}
meansCov <- colMeans(autodataCov)
covMat <- matrix(nrow = 5, ncol = 5)
for(i in 1:nrow(covMat)){
for(j in 1:ncol(covMat)){
covMat[i,j] <- mean(autodataCov[,i] * autodataCov[,j])
}
}
corrMat <- matrix(nrow = 5, ncol = 5)
for(i in 1:nrow(corrMat)){
for(j in 1:ncol(corrMat)){
corrMat[i,j] <- covMat[i,j] /
(standardDeviation(autodata[,i])*standardDeviation(autodata[,j]))
}
}
?prcomp
corrMat
prcomp(corrMat, center = TRUE, scale. = TRUE)
proj <- eigen(corrMat)
eigen(corrMat)
prcomp(corrMat, center = TRUE, scale. = TRUE)
pairs(prcomp(corrMat, center = TRUE, scale. = TRUE))
prcomp(corrMat, center = TRUE, scale. = TRUE)
type(prcomp(corrMat, center = TRUE, scale. = TRUE))
typeof(prcomp(corrMat, center = TRUE, scale. = TRUE))
pairs(prcomp(corrMat, center = TRUE, scale. = TRUE))
pca <- prcomp(corrMat, center = TRUE, scale. = TRUE)
pca[PC1]
pca["PC1"]
pca
pca[["PC1"]]
pca$PC1
pca$Rotation
pca
pca["Rotation"]
pca[Rotation]
pca <- prcomp(corrMat, center = TRUE, scale. = TRUE)
pca$rotation
eigen(corrMat)
pca
pca$center
pca$scale
proj$values
pairs(pca)
pairs(as.matrix(pca))
pca
pairs(pca$rotation)
pairs(autodata %*% pca$rotation)
pairs(autodata)
proj <- eigen(corrMat)
pairs(autodata %*% proj$vectors)
C <- matrix(cbind(1,.8,.6, .8,1,.7, .6,.7,1),nrow=3)
U <- t(chol(C))
nvars <- dim(U)[1]
numobs <- 10000
set.seed(42)
random.normal <- matrix(rnorm(nvars*numobs,0,1), nrow = nvars, ncol = numobs)
X <- t(U %*% random.normal)
raw <- as.data.frame(X)
names(raw) <- c("claims", "potholes", "emergencies")
cor(raw)
pairs(head(raw, 500))
pairs(head(proj,500))
proj <- as.matrix(raw) %*% eigen(cor(raw))$vectors
pairs(head(proj,500))
setwd("E:/Downloads/Courses/CUNY/SPS/Git/IS 605 Fundamentals of Computational Mathematics/Assignment 7")
autodata <- scan("auto-mpg.data")
autodata <- t(matrix(autodata, nrow = 5))
means <- colMeans(autodata)
autodataCov <- matrix(ncol = ncol(autodata), nrow = nrow(autodata))
for(i in 1:ncol(autodata)){
autodataCov[,i] <- autodata[,i] - means[i]
}
meansCov <- colMeans(autodataCov)
standardDeviation <- function(vec){
return(sqrt(sum((vec-expectedValue(vec))^2)/(length(vec)-1)))
}
expectedValue <- function(vec){
return(sum(vec)/length(vec))
}
setwd("E:/Downloads/Courses/CUNY/SPS/Git/IS 605 Fundamentals of Computational Mathematics/Assignment 7")
autodata <- scan("auto-mpg.data")
autodata <- t(matrix(autodata, nrow = 5))
means <- colMeans(autodata)
autodataCov <- matrix(ncol = ncol(autodata), nrow = nrow(autodata))
for(i in 1:ncol(autodata)){
autodataCov[,i] <- autodata[,i] - means[i]
}
meansCov <- colMeans(autodataCov)
covMat <- matrix(nrow = 5, ncol = 5)
for(i in 1:nrow(covMat)){
for(j in 1:ncol(covMat)){
covMat[i,j] <- mean(autodataCov[,i] * autodataCov[,j])
}
}
corrMat <- matrix(nrow = 5, ncol = 5)
for(i in 1:nrow(corrMat)){
for(j in 1:ncol(corrMat)){
corrMat[i,j] <- covMat[i,j] /
(standardDeviation(autodata[,i])*standardDeviation(autodata[,j]))
}
}
proj <- audodata %*% eigen(corrMat)$vectors
setwd("E:/Downloads/Courses/CUNY/SPS/Git/IS 605 Fundamentals of Computational Mathematics/Assignment 7")
autodata <- scan("auto-mpg.data")
autodata <- t(matrix(autodata, nrow = 5))
means <- colMeans(autodata)
autodataCov <- matrix(ncol = ncol(autodata), nrow = nrow(autodata))
for(i in 1:ncol(autodata)){
autodataCov[,i] <- autodata[,i] - means[i]
}
meansCov <- colMeans(autodataCov)
covMat <- matrix(nrow = 5, ncol = 5)
for(i in 1:nrow(covMat)){
for(j in 1:ncol(covMat)){
covMat[i,j] <- mean(autodataCov[,i] * autodataCov[,j])
}
}
corrMat <- matrix(nrow = 5, ncol = 5)
for(i in 1:nrow(corrMat)){
for(j in 1:ncol(corrMat)){
corrMat[i,j] <- covMat[i,j] /
(standardDeviation(autodata[,i])*standardDeviation(autodata[,j]))
}
}
proj <- autodata %*% eigen(corrMat)$vectors
pairs(autodata)
pairs(proj)
proj <- autodata %*% t(eigen(corrMat)$vectors)
pairs(proj)
proj <- autodata %*% eigen(corrMat)$vectors
pairs(proj)
proj <- eigen(corrMat)$vectors %*% autodata
proj <- autodata %*% eigen(corrMat)$vectors
autodata
eigen(corrMat)$vectors
corrMat
cor(autodata)
proj <- autodata %*% eigen(cor(autodata))$vectors
pairs(proj)
pairs(autodata %*% proj$vectors)
proj <- autodata %*% eigen(covMat)$vectors
pairs(proj)
eigen(covMat)$vectors
prcomp(corrMat, center = TRUE, scale. = TRUE)
pca <- prcomp(corrMat, center = TRUE, scale. = TRUE)
pca
proj2 <- autodata %*% pca$rotation
pairs(proj2)
pca$rotation
pca$rotation[,PC1]
pca$rotation[,"PC1"]
pca$rotation[,"PC1"] %*% t(pca$rotation[,"PC2"])
pca$rotation[,"PC1"] %*% pca$rotation[,"PC2"]
pca$rotation %*% autodata
autodata %*% pca$rotation
pairs(autodata %*% pca$rotation)
pairs(autodata %*% t(pca$rotation))
pairs(autodata %*% pca$rotation)
pairs(autodata %*% pca$rotation)
pca <- prcomp(covMat, center = TRUE, scale. = TRUE)
pca
proj2 <- autodata %*% pca$rotation
pairs(proj2)
pca
eigen(covMat)
pca <- prcomp(covMat, center = TRUE, scale. = TRUE)
pca <- prcomp(covMat, center = TRUE, scale. = FALSE)
proj2 <- autodata %*% pca$rotation
pairs(proj2)
pca
eigen(covMat)$vectors
prcomp(covMat, center = TRUE, scale. = FALSE)
prcomp(covMat, center = TRUE, scale. = FALSE)
prcomp(covMat, center = TRUE, scale. = TRUE)
pcatrue <- prcomp(covMat, center = TRUE, scale. = TRUE)
pcafalse <- prcomp(covMat, center = TRUE, scale. = FALSE)
pcatrue$rotation[,"PC1"]
pcafalse$rotation[,"PC1"]
pcatrue$rotation[,"PC1"] / pcafalse$rotation[,"PC1"]
?prcomp
prcomp(covMat, center = TRUE, scale. = FALSE)
prcomp(covMat, center = TRUE, scale. = TRUE)
pcatrue <- prcomp(covMat, center = TRUE, scale. = TRUE)
pcatrue$rotation
pcatrue$rotation[,"PC1"] %*% pcatrue$rotation[,"PC2"]
pcatrue$rotation[,"PC1"] %*% pcatrue$rotation[,"PC3"]
pcatrue$rotation[,"PC1"] %*% pcatrue$rotation[,"PC4"]
pcatrue$rotation[,"PC1"] %*% pcatrue$rotation[,"PC5"]
pcatrue$rotation[,"PC4"] %*% pcatrue$rotation[,"PC5"]
pcatrue$rotation[,"PC3"] %*% pcatrue$rotation[,"PC5"]
pcatrue$rotation[,"PC3"]
pairs(autodata %*% pcatrue$rotation)
pairs(autodata %*% pcafalse$rotation)
pairs(autodata %*% prcomp(corrMat, center = TRUE, scale. = TRUE)
asdf
asdf
pairs(prcomp(corrMat, center = TRUE, scale. = TRUE))
corrMat
pairs(prcomp(corrMat, center = TRUE, scale. = TRUE))
pairs(prcomp(covMat, center = TRUE, scale. = TRUE))
pairs(autodata %*% prcomp(corrMat, center = TRUE, scale. = TRUE))
pcatrue <- prcomp(covMat, center = TRUE, scale. = TRUE)
pcafalse <- prcomp(covMat, center = TRUE, scale. = FALSE)
pcatruecov <- prcomp(covMat, center = TRUE, scale. = TRUE)
pcafalsecov <- prcomp(covMat, center = TRUE, scale. = FALSE)
pcatruecorr <- prcomp(corrMat, center = TRUE, scale. = TRUE)
pcafalsecorr <- prcomp(corrMat, center = TRUE, scale. = FALSE)
pairs(autodata %*% pcatruecov$rotation)
pairs(autodata %*% pcatruecorr$rotation)
pairs(autodata %*% pcafalsecov$rotation)
pairs(autodata %*% pcatruecov$rotation)
pairs(autodata %*% pcatruecov$rotation)
pairs(autodata %*% pcatruecorr$rotation)
