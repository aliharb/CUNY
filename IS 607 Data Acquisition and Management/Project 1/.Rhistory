c(1,1)
list(c(1,1),c(1,1))
gy
fc <- forecast(gy)
fc
rm(fc)
rm(list=ls(all=TRUE))
library(DMwR)
print(version)
library(DMwR)
install.packages("DMwR")
library(DMwR)
d <- sales
print(version)
x <- c("a", "b", "c", "d")
rm(list=ls(all=TRUE))
y <- 1:4
x <- c("a", "b", "c", "d")
df <- data.frame(x,y)
as.character
as.character(df$x)
df$x <- as.character(df$x)
queue <- c("james", "Mary", "Steve", "Alex", "Patricia")
queue <- c("james", "Mary", "Steve", "Alex", "Patricia")
queue
queue[1]
queue <- c(queue, "Harold")
queue[queue != "Mary"]
queue <- queue[queue != "James"]
queue <- c("James", "Mary", "Steve", "Alex", "Patricia")
queue <- c(queue, "Harold")
queue <- queue[queue != "James"]
queue[queue = "James"]
queue[queue = "Mary"]
?append
append(queue, "Pam", after = 3)
append(queue, "Pam", after = 2)
append(queue, "Pam", after = 1)
queue <- queue[queue != "Harold"]
queue <- queue[queue != "Alex"]
match("steve", queue)
match("Steve", queue)
Patricia.Position <- match("Patricia", queue)
Patricia.Position + 3
Queue.Length <- length(queue)
queue <- c("James", "Mary", "Steve", "Alex", "Patricia")
queue <- c(queue, "Harold")
queue <- queue[queue != "James"]
queue <- append(queue, "Pam", after = 1)
queue <- queue[queue != "Harold"]
queue <- queue[queue != "Alex"]
Patricia.Position <- match("Patricia", queue)
Queue.Length <- length(queue)
x <- 4
"hello" + x
"hello" + as.character(x)
paste("Hello", x, sep=" ")
quadraticSolve <- function(a, b, c){
if(b^2 - 4*a*c < 0){
return("This quadratic equation has no real solutions.")
} else {
x1 <- (-b + sqrt(b^2 - 4*a*c))/(2*a)
x2 <- (-b - sqrt(b^2 - 4*a*c))/(2*a)
if(x1 == x2){
return(paste("This quadratic equation has one solution:", x1, sep=" "))
} else {
return(paste("This quardatic equation has two solutions:", x1, "and", x2, sep=" "))
}
}
}
quadraticSolve(1,2,1)
quadraticSolve(1,0,-1)
quadraticSolve(12,2,12)
vec <- c()
vec <- c(vec, 2)
vec <- c(vec, 2, 3)
5%/%2
5%%2
count <- 0
vec <- c()
for(n in 1:1000){
if(n%%7 != 0 | n%%3 != 0 | n%%11 != 0){
count <- count + 1
vec <- c(vec, n)
}
}
vec
1%%3
count <- 0
vec <- c()
for(n in 1:1000){
if(n%%7 != 0 & n%%3 != 0 & n%%11 != 0){
count <- count + 1
vec <- c(vec, n)
}
}
vec
pythag <- function(f,g,h){
#This function takes in three numbers: f, g, and h.
#It returns TRUE if the numbers form a pythagorean triple, and FALSE if they don't.
if(f^2+g^2==h^2 | f^2+h^2==g^2 | g^2+h^2==f^2){
return(TRUE)
} else {
return(FALSE)
}
}
pythag(3,4,5)
pythag(4,4,5)
pythag(12,13,5)
pythag <- function(f,g,h){
#This function takes in three numbers: f, g, and h.
#It returns TRUE if the numbers form a pythagorean triple, and FALSE if they don't.
if(f^2+g^2==h^2 | f^2+h^2==g^2 | g^2+h^2==f^2){
return(TRUE)
} else {
return(FALSE)
}
}
queue <- c("James", "Mary", "Steve", "Alex", "Patricia")
##### Part b #####
queue <- c(queue, "Harold")
##### Part c #####
queue <- queue[queue != "James"]
##### Part d #####
queue <- append(queue, "Pam", after = 1)
##### Part e #####
queue <- queue[queue != "Harold"]
##### Part f #####
queue <- queue[queue != "Alex"]
##### Part g #####
Patricia.Position <- match("Patricia", queue)
queue <- c("James", "Mary", "Steve", "Alex", "Patricia")
##### Part b #####
queue <- c(queue, "Harold")
##### Part c #####
queue <- queue[queue != "James"]
##### Part d #####
queue <- append(queue, "Pam", after = 1)
##### Part e #####
queue <- queue[queue != "Harold"]
##### Part f #####
queue <- queue[queue != "Alex"]
##### Part g #####
Patricia.Position <- match("Patricia", queue)
##### Part h #####
Queue.Length <- length(queue)
vec <- c(1,2,3,4,5)
mean(vec)
vec <- c(1,2,3,NA,5)
mean(vec)
vec <- c(1,2,3,4,5)
vecMean <- function(vec){
#Takes in a vector and returns the mean.
return(mean(vec))
}
vecMean(vec)
vec <- c(1,2,null,4)
vec <- c(1,2,NULL,4)
vec
vec <- c(1,2,NA,4,5)
is.na(vec[3])
vec[vec != NA]
vec[vec != 2]
vec[vec != NA]
length(vec)
vec[0]
length(vec)
1:length(vec)
vec[!vec == NA]
vec[vec == NA]
vec <- 1:5
count = 0
for(n in vec){
count = count + n
}
isna(NA)
vecMean <- function(vec){
#Takes in a vector and returns the mean of the observations, while handling NAs.
sum = 0
for(n in vec){
if(!is.na(n)){
sum = sum + n
}
}
}
vec <- c(1,2,5,NA,8)
vecMean(vec)
vecMean(vec)
vecMean <- function(vec){
#Takes in a vector and returns the mean of the observations, while handling NAs.
sum = 0
for(n in vec){
if(!is.na(n)){
sum = sum + n
}
}
return(sum/length(vec))
}
vecMean(vec)
5:1
4%%2
4%%3
gcd <- function(x,y){
gcdval <- 1
if(x < y){
for n in y:1{
if(y%%n == 0 & x%%n == 0){
gcd <- n
break
}
}
}
return(gcdval)
}
gcd <- function(x,y){
gcdval <- 1
if(x < y){
for n in y:1{
if(y%%n == 0 & x%%n == 0){
gcd <- n
break
}
}
} else {
for n in x:1{
if(y%%n == 0 & x%%n == 0){
gcd <- n
break
}
}
}
return(gcdval)
}
gcd <- function(x,y){
gcdval <- 1
if(x < y){
for n in y:1{
if(y%%n == 0 & x%%n == 0){
gcd <- n
break
}
}
}else{
for n in x:1{
if(y%%n == 0 & x%%n == 0){
gcd <- n
break
}
}
}
return(gcdval)
}
gcd <- function(x,y){
gcdval <- 1
if(x < y){
for n in y:1{
if(y%%n == 0 & x%%n == 0){
gcd <- n
break
}
}
}else{
for n in x:1{
if(y%%n == 0 & x%%n == 0){
gcd <- n
break
}
}
}
return(gcdval)
}
gcd <- function(x,y){
gcdval <- 1
if(x < y){
for n in y:1{
gcd <- function(x,y){
gcdval <- 1
if(x < y){
for(n in y:1){
if(y%%n == 0 & x%%n == 0){
gcd <- n
break
}
}
}else{
for n in x:1{
if(y%%n == 0 & x%%n == 0){
gcd <- n
break
}
}
}
return(gcdval)
}
gcd <- function(x,y){
gcdval <- 1
if(x < y){
for(n in y:1){
if(y%%n == 0 & x%%n == 0){
gcd <- n
break
}
}
}else{
for(n in x:1){
if(y%%n == 0 & x%%n == 0){
gcd <- n
break
}
}
}
return(gcdval)
}
gcd(20, 30)
x <- 40
x <- 40
for(n in x:1){
if(n == 26){
break
}
}
y <- 30
x <- 40
y <- 30
for(n in x:1){
if(y%%n == 0 & x%%n == 0){
break
}
}
x <- 20
y <- 30
x < y
gcd <- function(x,y){
gcdval <- 1
if(x < y){
for(n in y:1){
if(y%%n == 0 & x%%n == 0){
gcdval <- n
break
}
}
}else{
for(n in x:1){
if(y%%n == 0 & x%%n == 0){
gcdval <- n
break
}
}
}
return(gcdval)
}
gcd(20, 30)
47%%100
100%%47
gcd(20, 20)
gcd <- function(x,y){
if(x == y){
gcdval <- x
}else if(x > y){
gcd(x-y, y)
}else{
gcd(y-x, x)
}
}
gcd <- function(x,y){
if(x == y){
gcdval <- x
}else if(x > y){
gcd(x-y, y)
}else{
gcd(y-x, x)
}
return(gcdval)
}
gcd(252, 105)
gcd <- function(x,y){
if(x == y){
gcdval <- x
}else if(x > y){
gcd(x-y, y)
}else{
gcd(y-x, x)
}
return(gcdval)
}
gcd <- function(x,y){
if(x == y){
gcdval <- x
}else if(x > y){
gcd(x-y, y)
}else{
gcd(y-x, x)
}
return(gcdval)
}
gcd(252, 105)
print("Hello")
gcd <- function(x,y){
if(x == y){
print(x, y)
gcdval <- x
}else if(x > y){
print(x, y)
gcd(x-y, y)
}else{
print(x, y)
gcd(y-x, x)
}
return(gcdval)
}
gcd(252, 105)
x <- 252
y<-105
print(x, y)
print(x & y)
print(x)
print(c(x, y))
gcd <- function(x,y){
if(x == y){
print(c(x,y))
gcdval <- x
}else if(x > y){
print(c(x,y))
gcd(x-y, y)
}else{
print(c(x,y))
gcd(y-x, x)
}
return(gcdval)
}
gcd(252, 105)
x <- 21
y<-21
if(x==y){
gcdval <- x
}
gcd <- function(x,y){
if(x == y){
print(c(x,y))
gcdval <- x
}else if(x > y){
print(c(x,y))
gcd(x-y, y)
}else{
print(c(x,y))
gcd(y-x, x)
}
return(gcdval)
}
gcd(252, 105)
gcd <- function(x,y){
if(x == y){
gcdval <- x
}else if(x > y){
gcd(x-y, y)
}else{
gcd(y-x, x)
}
return(gcdval)
}
gcd(252, 105)
x <- 2
y <- 3
x^2*y
formulacalc <- function(x,y){
return(x^2*y + 2*x*y - x*y^2)
}
formulacalc(23,45)
x <- 23^2
x <- x*45
y <- 2*23*45
z <- 45^2
z <- z*23
x+y-z
workingDirectory <- "C:/Users/Charley/Downloads/Courses/CUNY/SPS/Git/IS 607 Data Acquisition and Management/Project 1"
setwd(workingDirectory)
data <- read.csv("entropy-test-file.csv", header=TRUE)
##### entropy function #####
entropy <- function(d){
d <- as.factor(d)
entropy <- 0
for(level in levels(d)){
p <- length(d[d==level])/length(d)
entropy <- entropy + p*log2(p)
}
return(-entropy)
}
workingDirectory <- "C:/Users/Charley/Downloads/Courses/CUNY/SPS/Git/IS 607 Data Acquisition and Management/Project 1"
setwd(workingDirectory)
data <- read.csv("entropy-test-file.csv", header=TRUE)
##### entropy function #####
entropy <- function(d){
d <- as.factor(d)
entropy <- 0
for(level in levels(d)){
p <- length(d[d==level])/length(d)
entropy <- entropy + p*log2(p)
}
return(-entropy)
}
entropy(data$answer)
infogain <- function(d,a){
combined <- data.frame(d,a)
ed <- entropy(combined$d)
ea <- 0
combined$a <- as.factor(combined$a)
for(level in levels(combined$a)){
w <- length(combined[combined$a==level,"d"])/length(combined$d)
ea <- ea + w*entropy(combined[combined$a==level,"d"])
}
return(ed-ea)
}
